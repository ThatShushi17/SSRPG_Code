/* ====================
    ANCHOR User Facing
:====================== */

// - = Behavior = -

var PositionCallback = null
var UIPositionCallback = null

var canMove = true
var canPerform = true
var positionX = null
var positionY = null

func ToggleCondition (condition)
  ?conditions.Contains(condition)
    Remove(condition, conditions)
  :
    conditions.Add(condition)


// - = Visual = -

var shinyWidth = 3
var shinyShear = 2
var shinyDelay = 30
var shinyTickSpeed = 1
var shinyTimer = shinyDelay

var shadeWidth = 3
var shadeShear = -4
var shadeDelay = 60
var shadeTickSpeed = 2
var shadeTimer = shadeDelay

var shinyGreys = [
  #000000,
  #252525,
  #494949,
  #6b6b6b,
  #898989,
  #a2a2a2,
  #b6b6b6,
  #c4c4c4,
  #cbcbcb,
  #cbcbcb,
  #c4c4c4,
  #b6b6b6,
  #a2a2a2,
  #898989,
  #6b6b6b,
  #494949,
  #252525,
  #000000
]
var shadeGreys = [
  #ffffff,
  #f0f0f0,
  #e1e1e1,
  #d2d2d2,
  #c4c4c4,
  #b7b7b7,
  #a9a9a9,
  #9d9d9d,
  #919191,
  #878787,
  #7d7d7d,
  #747474,
  #6d6d6d,
  #666666,
  #616161,
  #5d5d5d,
  #5a5a5a,
  #595959,
  #595959,
  #5a5a5a,
  #5d5d5d,
  #616161,
  #666666,
  #6d6d6d,
  #747474,
  #7d7d7d,
  #878787,
  #919191,
  #9d9d9d,
  #a9a9a9,
  #b7b7b7,
  #c4c4c4,
  #d2d2d2,
  #e1e1e1,
  #f0f0f0,
  #fefefe
]



/* ==================
    ANCHOR Functions
:==================== */

// -- Main ---------------------------- //

var canvii = null
var bindingUI = null
var conditions = []
var MainPerform = null
var EffectTileCallback = null

func Main(mask)
  ?positionX ! null | positionY ! null
    ?positionX ! null
      for canvas : canvii
        canvas.x = positionX
      positionX = null

    ?positionY ! null
      for canvas : canvii
        canvas.y = positionY
      positionY = null


  ?canPerform
    MainPerform(canvii, mask)


  ?!canMove
    return


  ?PositionCallback ! null & UIPositionCallback = ToBindingUI
    UIPositionCallback = null


  ?UIPositionCallback
    for canvas : canvii
      UIPositionCallback(canvas)

  :?PositionCallback
    for canvas : canvii
      canvas.x = PositionCallback()［0］
      canvas.y = PositionCallback()［1］



// -- General ------------------------- //

// dependencies
// ├─→ 0: canvas
// └─→ 1: colors
func ApplyColorFG(x, y, t, dependencies)
  var canvas = dependencies［0］
  var colors = dependencies［1］
  
  canvas.SetFG(x, y, colors［t］)

// dependencies
// ├─→ 0: canvas
// └─→ 1: colors
func ApplyColorBG(x, y, t, dependencies)
  var canvas = dependencies［0］
  var colors = dependencies［1］
  
  canvas.SetBG(x, y, colors［t］)

// expected wipeData
// ├─→ 0: count
// ├─→ 1: width
// ├─→ 2: shear
// ├─→ 3: ticksPerMove
// └─→ 4: EffectCallback()

func WipePattern(size, mask, timer, wipeData,
^dependencies)
  var t = math.Abs(timer)

  var canvasW = size［0］
  var canvasH = size［1］

  var count = wipeData［0］
  var wipeWidth = wipeData［1］
  var shear = wipeData［2］
  var tpMove = wipeData［3］
  var callback = wipeData［4］

  var elapsed = t / tpMove
  var initPhase = t % tpMove

  var phaseDel = shear * (canvasH - 1)
  var vertWidth = wipeWidth + math.Abs(phaseDel) / tpMove
  var startX
  var endX
  ?shear < 0
    startX = wipeWidth + vertWidth - 1
    endX = -wipeWidth
  :
    startX = canvasW - 1
    endX = -vertWidth

  ?startX - elapsed = endX
    return true

  for y = 0 .. canvasH - 1
    // for the start of the wipe
    var p0 = initPhase - y * shear
    var x0 = startX - elapsed - math.FloorToInt((p0 * 1.0) / tpMove)
    
    // for the mask
    var i = y * canvasW + x0
    var maskCond = string.Equals(mask, "1")

    for x = 0 .. wipeWidth - 1
      var p = Mod(p0, tpMove)

      var posCond = false

      ?x0 + x >= 0 & x0 + x < canvasW
        posCond = true

      ?!maskCond & posCond
        maskCond = string.Equals(string.Sub(mask, i + x, 1), ＂1＂)

      ?posCond & maskCond
        p += x * tpMove

        callback(x0 + x, y, p, dependencies)



// -- Specific ------------------------ //

func ToBindingUI(canvas)
  canvas.x = bindingUI.x
  canvas.y = bindingUI.y


func InitShinyEffect(model)
  var x
  var y
  var w
  var h
  ?type(model) = ＂array＂
    x = model［0］
    y = model［1］
    w = model［2］
    h = model［3］
  :
    x = model.x
    y = model.y
    w = model.w
    h = model.h
    UIPositionCallback = ToBindingUI
    bindingUI = model


  var dCanvas = ui.AddCanvas()
  dCanvas.dock = ＂top_left＂
  dCanvas.anchor = ＂top_left＂
  dCanvas.x = x
  dCanvas.y = y
  dCanvas.w = w
  dCanvas.h = h
  dCanvas.blend = ＂multiply＂
  dCanvas.Set("#")
  dCanvas.SetFG(#ffffff)

  var sCanvas = ui.AddCanvas()
  sCanvas.dock = ＂top_left＂
  sCanvas.anchor = ＂top_left＂
  sCanvas.x = x
  sCanvas.y = y
  sCanvas.w = w
  sCanvas.h = h
  sCanvas.blend = ＂add＂
  sCanvas.Set("#")
  sCanvas.SetFG(#000000)

  canvii = ［dCanvas, sCanvas］
  MainPerform = PerformShinyEffect
  EffectTileCallback = ApplyColorFG

func InitShinyEffectBG(model)
  InitShinyEffect(model)
  EffectTileCallback = ApplyColorBG

func PerformShinyEffect(canvii, mask)
  var pauseShade = conditions.Contains("pause_shade")
  var pauseShiny = conditions.Contains("pause_shiny")
  var disableShade = conditions.Contains("disable_shade")
  var disableShiny = conditions.Contains("disable_shiny")
  var playonceShade = conditions.Contains("playonce_shade")
  var playonceShiny = conditions.Contains("playonce_shiny")

  var shadeCanvas = canvii［0］
  var shinyCanvas = canvii［1］

  ?playonceShade & disableShade
    Remove("disable_shade", conditions)

  ?playonceShiny & disableShiny
    Remove("disable_shiny", conditions)

  ?!pauseShade & !disableShade
    shadeCanvas.SetFG(#ffffff)

    ?shadeTimer <= 0
      ?WipePattern(
      ^［shadeCanvas.w, shadeCanvas.h］,
      ^mask,
      ^shadeTimer,
      ^[
        shadeGreys.Count(),
        shadeWidth,
        shadeShear,
        shadeGreys.Count() / shadeWidth,  // shadeTicksPerMove
        EffectTileCallback
      ],
      ^［shadeCanvas, shadeGreys］
      ^)
        shadeTimer = shadeDelay

        ?playonceShade
          Remove("playonce_shade", conditions)
          conditions.Add("disable_shade")
    
    ?totaltime % shadeTickSpeed = 0
      shadeTimer--

  ?!pauseShiny & !disableShiny
    shinyCanvas.SetFG(#000000)

    ?shinyTimer <= 0
      ?WipePattern(
      ^［shinyCanvas.w, shinyCanvas.h］,
      ^mask,
      ^shinyTimer,
      ^[
        shinyGreys.Count(),
        shinyWidth,
        shinyShear,
        shinyGreys.Count() / shinyWidth,  // shinyTicksPerMove
        EffectTileCallback
      ],
      ^［shinyCanvas, shinyGreys］
      ^)
        shinyTimer = shinyDelay

        ?playonceShiny
          Remove("playonce_shiny", conditions)
          conditions.Add("disable_shiny")
  
    ?totaltime % shinyTickSpeed = 0
      shinyTimer--

  ?disableShade
    shadeCanvas.SetFG(#ffffff)
    shadeTimer = 0

  ?disableShiny
    shinyCanvas.SetFG(#000000)
    shinyTimer = 0


/* =====================
    ANCHOR Helper Funcs
:======================= */
// these are unrelated to the effects

// a proper one this time
func Mod(n, m)
  return ((n % m) + m) % m

// why must i make this myself?
func Remove(val, array)
  array.RemoveAt(array.IndexOf(val))
